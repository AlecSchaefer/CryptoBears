const utils = require('./Utils')
const BigNumber = require('bignumber.js')
const assertDiff = require('assert-diff')
assertDiff.options.strict = true

const CryptoBears = utils.CryptoBears
const BearBucks = utils.BearBucks
const BearCrowdsale = utils.BearCrowdsale
const ReentrancyExploit = utils.ReentrancyExploit
const checkState = utils.checkState
const expectRevert = utils.expectRevert
const getGasUsed = utils.getGasUsed
const updateBalances = utils.updateBalances
const getExpectedBalanceDelta = utils.getExpectedBalanceDelta

const zero = utils.zero
const pause = utils.pause

const startBalance = 100
const feedingCost = 20
const feedingInterval = 3000 // 1000ms == 1sec
const genes = 0
const name = 'Bruno'
const bearBucksPrice = 100;
const cryptoBearsPrice = 1000;


contract('VulnerabilityTests', async function (accounts) {

  beforeEach('Make fresh contract', async function () {
    referee = accounts[5] // We let accounts[5] represent the referee.
    minter = accounts[5] // We let accounts[5] also represent the minter.
    wallet = accounts[6] // We let accounts[6] represent the crowdsale wallet.
    cryptoBears = await CryptoBears.new(
      startBalance, feedingCost, feedingInterval/1000, referee)
    bearBucks = BearBucks.at(await cryptoBears._BearBucksContract.call())
    crowdsale = await BearCrowdsale.new(
      wallet,
      cryptoBears.address,
      bearBucksPrice,
      cryptoBearsPrice
    )
    // We let accounts[7] represent the hacker's account.
    reentrancy = await ReentrancyExploit.new(
      crowdsale.address, {from: accounts[7]}
    )
    await updateBalances(accounts)
  })


  it('example test 1', async function () {
    /**
     * We need to use await anytime we interact with our smart contracts.
     * By using the assertDiff library instead of assert we get nice color coded
     * output comparing the expected and actual results. By using deepEqual,
     * we make sure that both our expected and actual results are in the same
     * format. We can use .call() instead of .contractName() because we are just
     * reading information from the contract instead of modifying state. We can
     * and should use .call() anytime this is the case. To learn more about the
     * difference between calls and transactions, check out the truffle docs.
     * https://truffleframework.com/docs/truffle/getting-started/interacting-with-your-contracts
     */
    assertDiff.deepEqual(await cryptoBears.contractName.call(), 'CryptoBears')
    assertDiff.deepEqual(await bearBucks.contractName.call(), 'BearBucks')
    assertDiff.deepEqual(await crowdsale.contractName.call(), 'BearCrowdsale')
  })

  it('example test 2', async function () {
    /**
     * The extra {from: ...} parameter tells truffle which account to send the
     * transaction from.
     * We use .toNumber() because truffle returns uint256's from Solidity
     * contracts in a special format called BigNumber, which we need to convert
     * to a number.
     */
    await cryptoBears.newBear(genes, accounts[0], name, {from: minter})
    assertDiff.deepEqual((await bearBucks.balanceOf.call(accounts[0])).toNumber(), startBalance)
  })

  it('example test 3', async function () {
    /**
     * This test exploits a potential vulnerability that may be present in your
     * implementation.
     */

     // Use the minter account to mint bears for accounts 0 and 1.
     await cryptoBears.newBear(genes, accounts[0], 'Ted', {from: minter})
     await cryptoBears.newBear(genes, accounts[1], 'Pooh', {from: minter})

     // These are the bear's respective ID's.
     var ted = 0
     var pooh = 1

     // account0 places bet, approving the withdrawal first.
     await bearBucks.approve(cryptoBears.address, startBalance, {from: accounts[0]})
     await cryptoBears.placeBet(ted, pooh, startBalance, {from: accounts[0]})

     // account1 places bet, approving the withdrawal first.
     await bearBucks.approve(cryptoBears.address, startBalance, {from: accounts[1]})
     await cryptoBears.placeBet(pooh, ted, startBalance, {from: accounts[1]})

     /**
      * Seeing that account1 has placed their bet, account0 can now reduce
      * the cryptoBears contract's allowance to prevent withdrawal of their
      * funds if they lose.
      */
     await expectRevert(bearBucks.approve(cryptoBears.address, 0, {from: accounts[0]}))
     // await bearBucks.approve(cryptoBears.address, 0, {from: accounts[0]})

     /**
      * Notice that we put this step inside expectRevert(). This is because the
      * transaction should revert if the vulnerability is fixed. You should use
      * expectRevert whenever you write negative tests like this one. If you
      * were to comment out the top line and uncomment the one below it, and the
      * vulnerability were not fixed in your contract, then the code below would
      * work if uncommented. You can see that the contract's allowance would be
      * less than account0's betSum, which would mean that account0 could
      * gamble without ever risking money.
      */
     // var betSum = (await bearBucks.betSum.call(accounts[0])).toNumber()
     // var allowance = (await bearBucks.allowance.call(accounts[0], cryptoBears.address)).toNumber()
     // assert(betSum > allowance)
  })


  /* Find more vulnerabilities! */

  it('custom test name', async function() {
    //TODO: add vulnerability test here.
  })

  /* Begin Solution */
  it('competing allowance vulnerability', async function() {
    await cryptoBears.newBear(genes, accounts[0], name, {from: minter})
    await cryptoBears.newBear(genes, accounts[1], name, {from: minter})

    var smokey = 0
    var paddington = 1

    await bearBucks.approve(cryptoBears.address, startBalance, {from: accounts[0]})
    await cryptoBears.placeBet(smokey, paddington, startBalance, {from: accounts[0]})

    await bearBucks.approve(accounts[2], startBalance, {from: accounts[0]})
    await bearBucks.transferFrom(accounts[0], accounts[2], startBalance, {from: accounts[2]})

    var betSum = await bearBucks.betSum.call(accounts[0])
    var balance = await bearBucks.balanceOf.call(accounts[0])
    assert(betSum > balance)
  })
  /* End Solution */

  /* Begin Solution */
  it('crowdsale reentrancy vulnerability', async function() {
    await cryptoBears.setMinter(crowdsale.address, {from: accounts[5]})
    await updateBalances(accounts)

    var old_hacker_balance = await web3.eth.getBalance(accounts[7])

    var wei_used = cryptoBearsPrice
    var wei_returned = 1
    var wei_sent = wei_used + wei_returned

    await reentrancy.attack({value: wei_sent, from: accounts[7]})
    var gas_used = new BigNumber(await getGasUsed())


    var hacker_balance = (
      old_hacker_balance.minus(new BigNumber(gas_used)).minus(wei_used)
    ).toNumber()

    var cryptoBearsStateChanges = [
      {'var': 'minter', 'expect': crowdsale.address},
      {'var': 'balanceOf.a7', 'expect': 1},
      {'var': 'ownerOf.b0', 'expect': accounts[7]},
    ]
    var bearBucksStateChanges = [
      {'var': 'minter', 'expect': crowdsale.address},
      {'var': 'totalSupply', 'expect': startBalance},
      {'var': 'balanceOf.a7', 'expect': startBalance}
    ]
    var crowdsaleStateChanges = [
      {'var': 'weiRaised', 'expect': wei_used},
      {'var': 'wei_balance.a7', 'expect': hacker_balance},
    ]
    await checkState([cryptoBears, bearBucks, crowdsale], [cryptoBearsStateChanges, bearBucksStateChanges, crowdsaleStateChanges], accounts)
  })
  /* End Solution */

})
